"""Scaffold utilities for generating persistence code from templates.

Follows svc-infra's scaffold pattern using importlib.resources for template
loading and string.Template for variable substitution.
"""

import importlib.resources as pkg
from pathlib import Path
from string import Template as _T
from typing import Any, Dict


def render_template(tmpl_dir: str, name: str, subs: dict[str, Any] | None = None) -> str:
    """Load template from package resources and substitute variables.

    Uses importlib.resources to load .tmpl files from packages, then
    performs variable substitution using Python's string.Template.

    Args:
        tmpl_dir: Package path (e.g., 'fin_infra.budgets.templates')
        name: Template filename (e.g., 'models.py.tmpl')
        subs: Variables to substitute (e.g., {'Entity': 'Budget', 'table_name': 'budgets'})

    Returns:
        Rendered template string with variables substituted

    Example:
        >>> render_template(
        ...     'fin_infra.budgets.templates',
        ...     'models.py.tmpl',
        ...     {'Entity': 'Budget', 'table_name': 'budgets'}
        ... )
        'class Budget(ModelBase): ...'

    Note:
        Uses safe_substitute() so missing variables are left as-is (${var})
        rather than raising KeyError. This allows optional template variables.
    """
    subs = subs or {}
    txt = pkg.files(tmpl_dir).joinpath(name).read_text(encoding="utf-8")
    return _T(txt).safe_substitute(subs)


def write(dest: Path, content: str, overwrite: bool = False) -> Dict[str, Any]:
    """Write content to file with overwrite protection.

    Creates parent directories automatically and provides overwrite protection
    with clear result reporting.

    Args:
        dest: Destination file path (will be resolved to absolute path)
        content: Content to write to the file
        overwrite: If True, overwrite existing files. If False, skip existing files.

    Returns:
        dict: Result dictionary with keys:
            - path: str - Absolute path to the file
            - action: 'wrote' | 'skipped' - What action was taken
            - reason: str (optional) - Why the file was skipped (if action='skipped')

    Example:
        >>> write(Path("app/models/budget.py"), "class Budget: ...", overwrite=False)
        {"path": "/abs/path/app/models/budget.py", "action": "wrote"}

        >>> write(Path("app/models/budget.py"), "class Budget: ...", overwrite=False)
        {"path": "/abs/path/app/models/budget.py", "action": "skipped", "reason": "exists"}

    Note:
        Parent directories are created automatically using mkdir(parents=True, exist_ok=True).
    """
    dest = dest.resolve()
    dest.parent.mkdir(parents=True, exist_ok=True)
    if dest.exists() and not overwrite:
        return {"path": str(dest), "action": "skipped", "reason": "exists"}
    dest.write_text(content, encoding="utf-8")
    return {"path": str(dest), "action": "wrote"}


def ensure_init_py(
    dir_path: Path, overwrite: bool, paired: bool, content: str
) -> Dict[str, Any]:
    """Create __init__.py file with optional re-exports.

    Wrapper around write() specifically for creating __init__.py files.
    Supports 'paired' mode for generating re-exports of models and schemas.

    Args:
        dir_path: Directory where __init__.py should be created
        overwrite: If True, overwrite existing __init__.py
        paired: If True, content should include re-exports (e.g., from .models import ...)
                If False, content is typically minimal (empty or just docstring)
        content: The content to write to __init__.py

    Returns:
        dict: Same format as write() - {"path": str, "action": "wrote|skipped"}

    Example:
        >>> # Paired mode with re-exports
        >>> content = '''from .budget import BudgetModel
        ... from .budget_schemas import Budget, BudgetCreate, BudgetUpdate
        ... __all__ = ["BudgetModel", "Budget", "BudgetCreate", "BudgetUpdate"]
        ... '''
        >>> ensure_init_py(Path("app/models"), overwrite=False, paired=True, content=content)
        {"path": "/abs/path/app/models/__init__.py", "action": "wrote"}

        >>> # Minimal mode
        >>> ensure_init_py(Path("app/models"), overwrite=False, paired=False, content="")
        {"path": "/abs/path/app/models/__init__.py", "action": "wrote"}

    Note:
        The 'paired' parameter is informational - the actual re-export logic
        should be in the content string generated by the caller.
    """
    return write(dir_path / "__init__.py", content, overwrite)
